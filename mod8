M R PIGS
M R NOT PIGS
LIB M R PIGS

Libraries Overview
In computer science, library has a few definitions. For the purposes of this course, and its security context, libraries are resources that contain code and/or data. Modern desktop and server OSs contain methodologies for loading and managing these libraries. While libraries are often used for native code that can be referenced via C/C++ or other languages with the ability to bind or link to native libraries, many managed languages and runtimes — such as .NET and Java — also use libraries for shared code or data.

Libraries are referenced by new programs via a process known as linking. Libraries are linked statically or dynamically. Static linking copies all the referenced portions of the library into the resulting program image, while dynamic linking references the library instead of copying the library.

Static Libraries

On Windows, libraries that are intended to be statically linked use the .lib file extension by convention. Linux prepends these files with lib and the file ending with .a. Since static libraries are copied to, and included in, the resulting binary at compile time, updating these libraries generally requires recompiling the program.


Tradeoffs for static libraries:
Each application that references a static library requires the library to be loaded separately.May have performance implications due to being embedded in the application. This often results in larger assembly size, however, less overhead exists for method calls.
Application updates require recompilation and distribution of the executable in order to take advantage of security patches in newer versions of the library.Statically linked libraries require modification of the executable to tamper with the functions of the library, making them less susceptible to many library-based attacks.

Dynamic Libraries


On Windows, dynamic libraries use the .dll file extension by convention; Linux uses .so. These libraries are stored externally to the application, so they can be updated independently of the executable that uses them. In addition to compile-time linking, these libraries can be bound to at runtime — an example of which is using rundll32.exe to execute code found within a Dynamic Link Library (DLL).


These libraries are typically unchanged during runtime. Modern OSs typically only load one copy of a library into system memory, mapping any further calls to the same memory location.


Tradeoffs for dynamic libraries:
Most OSs share memory for each loaded library, meaning some memory savings are achieved for common libraries.Dynamic libraries can be updated independently of the program if binary compatibility is maintained by the new version of the library.Dynamic libraries, and their implementation, can be a source of security issues due to the possibility of an application loading a malicious library — for example, by replacing the original library or abuse of library search order.


Windows Libraries

On Windows, dynamic libraries can be found in various places. Libraries shared by multiple applications might exist in a specific shared library, like an installation in C:\Program Files\ or by convention by the library provider. Libraries are also found in an application’s directory or in Windows system folders like System32. On Windows systems, there are various readily available programs to view modules (libraries) loaded by processes including Process Explorer, Process Hacker, PowerShell’s Get-Process cmdlet, etc.

Processes with links to dynamic libraries typically search for libraries in the following ways:
Checks if the library is already loaded in memoryChecks if knowndlls registry entry exists for the DLLControlled by HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs — intended to speed up access to specific DLLs, however some security implications may exist if an attacker has elevated permissions on the host.
Searching through various paths, which can happen in one of several ways:SafeSearch order (determined by the HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode registry key) enabled by default — the registry key must be both present and set to zero to disable itLegacy Search Order — if SafeSearch is disabled, or if an insecure alternate search method is used, such as with the SearchPath method when SetSearchPathMode is set to disable SafeSearch
SafeSearch Order:
1 Directory application is located in
2 System directory (typically C:\Windows\System32)
3 16-bit System directory (typically C:\Windows\System)
4 Windows directory (typically C:\Windows\)
5 Current working directory
6 Directories listed in PATH environment variable

Legacy Search Order:
Directory application is located in and loaded fromCurrent working directorySystem directory (typically C:\Windows\System32)16-bit System directory (typically C:\Windows\System)Windows directory (typically C:\Windows\)Directories listed in PATH environment variable

(get-process explorer).modules
get-process explorer

Run the following commands to find the processes for the specified module:
PS C:\Users\trainee> $processes = Get-Process
PS C:\Users\trainee> foreach($process in $processes) {
 foreach($module in $process.Modules){
  if ($module.ModuleName -eq 'advapi32.dll'){
   $process
  }
 }
}
 Run the following command to store the credentials for the remote computer:
PS C:\Users\trainee> $credentials = Get-Credential

Use Invoke-Command to query the currently running processes on the remote computer cda-dc:
PS C:\Users\trainee> Invoke-Command -Credential $credentials -ComputerName 'cda-dc' -ScriptBlock {Get-Process}

use the following command to copy the collection locally:

PS C:\Users\trainee> $processes = Invoke-Command -Credential $credentials -ComputerName 'cda-dc' -ScriptBlock {Get-Process}

Examining Libraries
Analyst toolkits include many tools for viewing and interacting with dynamic libraries. There are several classes of tools for analyzing libraries and executables, such as:
Decompiler: Attempts to reconstruct a library or program executable into source code that can be compiled into the same assembly. May require formatting and relabeling code in order to be comprehensible.
Portable Executable (PE) Header/Metadata Analyzer: Examines the headers and other structures of an assembly to reveal information about the assembly, such as its dependencies and extracting resources from the file.
String Analyzer/Dumper: Dumps all strings contained in an assembly for analysis.
Disassembler: Breaks down native libraries into readable assembly code for analyzing behavior of a library or executable.
Hex Editor: Allows viewing and editing of raw binaries; displays data using hexadecimal. Often contains the ability to view binary as various data formats, such as strings or integers.

Decompilers Re-targetable Decompiler (RetDec) ILSpy (.NET)
PE Utilities CFF Explorer Resource Hacker
Disassemblers Ghidra Interactive Disassembler (IDA) Free
Hex Editors FileInsight HxD

ILSpyThis utility is used to decompile and examine a .NET library.
CFF ExplorerThis utility is used to explore imports and exports for a DLL.

Dynamic libraries are used to achieve an attacker’s goal, including:
Persistence 
Privilege Escalation 
Defense Evasion

What is a Windows Process?

A process is an executing program — typically based on the Portable Execution (PE) file format — isolated from other running programs on the same system. In other words, a process is a container that stores all the necessary components for executing a program independently from other programs.

A process has numerous elements including:
A private virtual memory space
An executable program image
Handles to kernel objects
A security token
A unique Process Identifier (PID)
One or more threads to execute instructions

These elements work in tandem by containing the data and carrying out the instructions that allow a process to run properly.

Virtual Memory Space

In Windows, memory space is divided into an area that user-mode processes access and a second area that is used exclusively by the kernel and kernel processes. 
The user mode virtual memory space is further divided between running processes. Each process’s user mode virtual memory space is private to that process; no processes are able to directly access another process’s virtual memory space. This is to prevent one process from interfering with another. However, such interference is possible through the Windows Application Programming Interface (API) and is demonstrated in other lessons. In contrast, kernel mode memory is shared by all processes on the system since there is only one kernel.

NOTE: Virtual memory is the modern OS’s representation of contiguous blocks of memory, whereas behind the scenes the processor is rapidly interchanging the data in use by Windows processes between Random Access Memory (RAM) and physical memory storage locations on the hard disk. These interchanges are seamless and transparent to the user, and allow larger programs to both become feasible and run faster. 
In 32-bit systems, each process is allocated 2 Gigabytes (GB) for its user-mode memory space while the kernel gets 2GB shared across all processes. In 64-bit systems, each process can theoretically be allocated Terabytes (TB) of user-mode memory space while the kernel also gets TBs of memory space across all processes.

This allocation is possible, even for systems that have a limited amount of RAM, through a process known as virtual memory mapping. With virtual memory mapping, each process sees the same range of memory addresses, but those addresses do not necessarily represent the real memory addresses in the computer’s physical RAM. Processes, however, treat virtual memory addresses as though they were physical memory addresses.

A wide range of additional information on virtual memory management can be found in the Microsoft documentation. 
The Windows Memory Manager, part of the kernel space Executive, decides where each process’s data is mapped in the computer’s physical RAM, or if it is stored on the computer’s hard drive in a process known as Paging.
The Windows Executive refers to the layer of kernel-mode components that provide a variety of services to device drivers, such as the management of objects, memory, processes and threads, inputs and outputs, and configurations.
Paging is the process by which Windows stores infrequently accessed information for processes on a system’s hard drive — in what is known as a paging file — freeing up space in the computer’s physical RAM. This promotes processing speed because accessing information in RAM is faster than information on the hard drive. When a process needs to access information stored in the paging file, a page fault occurs and Windows loads the necessary data from the page file into RAM.
Figure 8.2-1 illustrates how the Memory Manager maps virtual memory addresses for a process to the physical memory addresses in RAM and the paging file on disk.
Additional information about how paging works in Windows can be found in the Microsoft documentation. 

Although each process receives the same range of addresses within their private virtual memory space, processes are not guaranteed to use the same memory addresses within that private memory space each time they are run. Modern Windows processes take advantage of Address Space Layout Randomization (ASLR). ASLR is a security mechanism that instructs the Windows loader randomize the base memory address of executables and the position of libraries, heap, and the stack in a processes' address space. ASLR is primarily intended to defend against memory-based exploits like buffer overflows by eliminating an exploit’s ability to rely on hardcoded memory addresses. ASLR does not defeat memory based exploits or attacks, but increases the difficulty to reliably gain control of execution, reducing the likelihood of a successful attack.

When a process loads information into memory, it does so on the stack or the heap. The stack is an area of memory determined at compile time, and is used as storage for temporary variables and functions used by a program. The heap, in contrast, is used to store data that is provided to the process at runtime because the developer cannot anticipate exactly what information is input into the program in advance. Memory used by variables and functions stored in the stack is freed by the system automatically, whereas memory allocated on the heap must be specifically freed by the developer that coded the program.

Notably, in the interest of being memory efficient, system Dynamic Link Libraries (DLL) are shared between processes and commonly mapped to the same locations in virtual memory. Notepad.exe and MicrosoftEdge.exe have the DLL urlmon.dll mapped to the same location, for example 0x7ffcd1490000.

Handles to Kernel Objects

Kernel objects are, generally speaking, the system elements Windows exposes to user processes to allow them to perform a wide array of actions within the system. 

Example actions include:
Creating a windowOutputting text to the screenCreating, reading, editing, or deleting a file

Any action that involves interaction with a computer’s hardware requires assistance from the kernel. A handle is a reference to a resource. A process maintains a table of handles so it can access other resources on the system. In the case of kernel objects, handles are how programs are able to identify kernel elements and send instructions for performing the actions mentioned above. Handles are often used in conjunction with Windows API calls to access the details of a process, thread, or file.

When a handle for a kernel object is sought, the Executive’s object manager instantiates the requested kernel object. Kernel objects maintain a reference counter, which keeps track of how many processes are interacting with it. Every time a handle is retrieved for a kernel object, its reference counter is incremented by one. Each time a handle is released by a process, its reference counter is decremented by one. When the reference counter reaches zero, the kernel object is destroyed and its memory freed.

Additional information about handles and objects can be found in the Microsoft documentation. 

Security Token

When a user logs into Windows, the system generates and associates a security token with that user account. Each process that user starts receives the security token, which includes the identity and privileges of the user account. Windows uses the process’s security token to determine whether it is allowed to interact with a given resource, such as a file, or engaged in a privileged act. Security tokens contain a range of information, such as the Security Identifier (SID) of the originating user account, the SIDs for the groups which the account is a member, and a list of privileges held by that user or that user’s groups.

A wide range of information about security tokens, also called access tokens, can be found in the Microsoft documentation.

Unique PID

Each process, when it is created, receives a unique PID. A PID can be used to locate a running process and create a handle to it, like a kernel object. A process’s Identifier (ID) is unique only so long as the process is running. Terminated processes free their IDs, which can then be used by other new processes on the system.

What is a Windows Thread

A thread is a type of entity within a process that actually executes instructions within a process. Without at least one thread, processes are unable to function, and modern Windows processes typically have multiple threads at any given time. Each created process starts with one primary thread, which may then spawn additional threads. Each thread shares the process’s virtual memory space and system resources with other threads.

A thread has multiple components:
MemoryExecution contextThread local storageSecurity tokenMessage queueThread IDStatePriority
Windows Threads
What is a Windows Thread?
﻿
A thread is a type of entity within a process that actually executes instructions within a process. Without at least one thread, processes are unable to function, and modern Windows processes typically have multiple threads at any given time. Each created process starts with one primary thread, which may then spawn additional threads. Each thread shares the process’s virtual memory space and system resources with other threads.

A thread has multiple components:

Memory
Execution context
Thread local storage
Security token
Message queue
Thread ID
State
Priority
﻿
Memory

Each new thread receives its own memory stack which it uses to store local variables and return addresses of functions it calls. Memory can also be dynamically allocated by a thread, which would be in the process’s heap; dynamic memory is shared between threads, while the stack memory is not.

Execution Context

A thread’s context stores all the information the thread needs to execute its instructions, such as the value registers contained in the Instruction Pointer (Extended Instruction Pointer [EIP] on 32-bit systems and Return Instruction Pointer [RIP] on 64-bit systems). Because a Central Processing Unit (CPU) core can only execute one instruction from a thread at a time, processors need to switch between executing different threads frequently. Even multi-core processors — which can execute instructions in parallel — can be easily outnumbered by the amount of threads running on a single program, let alone all the processes running on Windows. The execution context is important because the OS is constantly switching between executing different threads — even across different processes. The context allows the thread to pick up where it left off while the OS allows it to continue its execution. Windows uses a mechanism called Scheduling to decide which threads to pause and which threads to allow to execute.

More detail about Scheduling can be found in the Microsoft documentation. 

Thread Local Storage (TLS)

TLS provides a mechanism for a thread to store data relevant only to it — without needing to share that information across other threads.

More information about TLS can be found in the Microsoft documentation. 

Security Token

By default, a thread inherits the security token held by the process in which it spawns. However, threads also have the ability to impersonate another account, which allows them to access resources and perform privileged actions within the impersonated user’s security context. The token, which the thread inherits, is known as the primary token and, if impersonating another user’s security context, it also has an impersonation token.

Impersonation tokens are described in greater depth in the Microsoft documentation. 

Message Queue

If a thread is intended to perform GUI actions, it has a message queue for receiving any events associated with its User Interface (UI).

Thread ID

Like processes, threads also have unique IDs that other applications can use to identify specific threads and create handles pointing to them. A thread ID is only unique for as long as a thread exists; once a thread has finished executing, its ID is relinquished and can be reused by the system for a new thread.

State

Each thread has a state which represents whether it is currently executing instructions. For example, some states include Ready (meaning the thread is available for the OS to execute it), Standby (meaning the thread has been selected as the next thread to execute), Wait (meaning the thread is currently paused and waiting for an operation to complete or a resource to become free), and Running (meaning the thread is currently executing).

More information about thread states can be found in the Microsoft documentation.

Priority

Each thread has a priority that works in concert with scheduling. Priorities rank from Lowest to Highest with categories like AboveNormal and BelowNormal in-between. By default, threads have the Normal priority, which is right in the middle, but that can be modified programmatically. Threads are scheduled for execution based on their priority. 


Finally, it may be necessary to run any of these commands on a remote computer to which an analyst has authenticated access. The format for such a command is 


[tasklist | taskkill] /S [computer name | IP address] /U [username] /P [password] [remaining options]

/F allows cmd to copy itens tbat normnally cannot be 
C:\Windows\system32>tasklist /S CDA-ACCT-1 /U "CDA\trainee" /P "Th1s is 0perational Cyber Training!"
Not only is the parent process interesting, sometimes it is useful to know which user account started the process. This can be done in two different ways in PowerShell — through the native Get-Process cmdlet or through WMI using the CIM cmdlets.

The syntax for getting the owner of a specific process is 

Get-Process -name [name] -IncludeUserName
or
Get-CimInstance -class Win32_Process -filter "name = '[name]'" | Invoke-CimMethod -MethodName GetOwner
The -filter flag filters output on the query which follows. Queries take on the format "[property] = [value]"The Invoke-CimMethod cmdlet uses the WMI GetOwner method to retrieve the username of the process
12. Print the owner of the powershell.exe process.

a. Use the native PowerShell command

PS C:\windows\system32>Get-Process -name powershell -IncludeUserName
run the following command to see which parent process ID spawns the running processes
NOTE: The -Force option is equivalent to the /F flag from taskkill. This may be a helpful option to add to commands that kill potentially malicious processes.


At times, it is not only helpful to know what the process information is, but also which processes created them. Recall from the Windows Management Interface (WMI) lesson that this information is stored in Common Information Model (CIM) objects. PowerShell is able to access these objects with the cmdlet Get-CimInstance.



PS C:\Windows\system32>Get-CimInstance -Class Win32_Process | Select-Object ProcessId,ProcessName,ParentProcessId
In this command:
-Class Win32_Process is an option that creates a list of WMI objects which are only running Windows processes| Select-Object pipes the output of the Get-CimInstance cmdlet to the Select-Object cmdlet, which filters the output by the variables which follow: ProcessId,ProcessName,ParentProcessId
Print the WMI object for the powershell.exe process with the command

PS C:\windows\system32>Get-CimInstance -class Win32_Process -filter "name = 'powershell.exe'" | Format-List *
NOTE: The | Format-List * cmdlet appended to the end of these commands formats the output of the commands so that each property of each object returned is printed on its own line. This formatting makes some output more readable and prevents long strings from being truncated. 

Finally, as with the Windows CLI, it may be necessary to run any of these PowerShell cmdlets on a remote computer to which an analyst has authenticated access. The format for such a command is 

Invoke-Command -ComputerName [Computer Name] -ScriptBlock {[PowerShell Expression]}

13. Retrieve a list of running processes on neighboring computer CDA-ACCT-1 with the command:

PS C:\Windows\system32>Invoke-Command -ComputerName CDA-ACCT-1 -ScriptBlock {Get-Process}

Since searching for individual process names can be tedious, PowerShell allows searching for multiple process names at once.

The syntax for filtering running processes by several process names is

Get-Process -name [name1],[name2],[...]

7. Find all processes beginning with the characters exp and pow with the command:

PS C:\Windows\system32>Get-Process -name exp*,pow*

NOTE: The use of the wildcard character (*) here allows the cmdlet to search for a pattern, rather than needing to articulate the exact name.
Standard Windows Processes
Each of the following processes is standard in Windows OSs, and a thorough understanding of these makes the identification of non-standard processes much easier.

﻿

System
﻿

This is the process from which all other processes are initiated and is responsible for system memory and memory management in the Windows kernel. It is always PID 4 — any other PID is suspect. 

﻿

System Idle Process
﻿

This process is simply a measure of how much free processor time is available. The amount of CPU time the system idle process is not occupying determines how much processing capability is currently applied to run actual tasks.

﻿

Session Manager Subsystem — smss.exe
﻿

This is a startup process activated by the main System process that creates environment variables, starts the kernel and user modes of the Win32 subsystem, creates Disk Operating System (DOS) device mappings, creates virtual memory paging files, and starts the Windows login manager.

﻿

Client Server Runtime Subsystem — csrss.exe
﻿

This critical system process is a user-mode system service in the Win32 subsystem, which is primarily responsible for Win32 console handling and GUI shutdown.

﻿

Windows Initialization — wininit.exe
﻿

This process launches the Windows initialization procedure, which includes starting the majority of the background applications that are constantly running, such as the Service Control Manager, the Local Security Authority Subsystem Service, and the Local Session Manager.

﻿

Service Control Manager — services.exe
﻿

This process is a service started at boot that provides a Remote Procedure Call (RPC) interface for maintaining the database of installed services, starting services and driver services either upon system startup or upon demand, enumerating installed services and driver services, maintaining status information for running services and driver services, transmitting control requests to running services, and locking and unlocking the service database.

﻿

Additional Resources

MITRE Adversarial Tactics, Techniques, and Common Knowledge (ATT&CK) System Services: Service Execution: https://attack.mitre.org/techniques/T1569/002/
MITRE ATT&CK Create or Modify System Process: Windows Service: https://attack.mitre.org/techniques/T1543/003/
MITRE ATT&CK Execution: https://attack.mitre.org/tactics/TA0002/
﻿

Local Security Authority Subsystem Service — lsass.exe
﻿

This process is responsible for enforcing security policy on the system, including logon verification, password policy, writing to Windows security logs, and the creation of access tokens. Credentials are often stored in lsass process memory for use by accounts during a login session. Since it contains those credentials, dumping lsass memory is a valued target of threat actors during the following types of attacks:

MITRE ATT&CK OS Credential Dumping: LSASS Memory T1003.001: https://attack.mitre.org/techniques/T1003/001/ 
MITRE ATT&CK Boot or Logon Autostart Execution: LSASS Driver T1547.008: https://attack.mitre.org/techniques/T1547/008/ 
MITRE ATT&CK Modify Authentication Process T1556: https://attack.mitre.org/techniques/T1556/ 
﻿

These techniques are grouped under the MITRE Tactics:

MITRE ATT&CK Persistence TA0003.008: https://attack.mitre.org/tactics/TA0003/ 
MITRE ATT&CK Privilege Escalation TA0004.004: https://attack.mitre.org/tactics/TA0004/ 
﻿

Service Host Process — svchost.exe
﻿

Svchost.exe is a generic host process name for services that run from DLLs. Since DLLs cannot be run directly, the service host process is an executable shell that loads the Windows services libraries and executes them. There are often many svchost.exe entries in a running process list because if a single process was hosting every necessary Windows service, then the failure of that process would cause OS failure. So individual services are started from discrete instances of the service host process. Figure 8.2-41 is a screenshot of the Task Manager Details tab showing many svchost.exe processes running.

﻿

﻿

Figure 8.2-41

﻿

Figure 8.2-42 shows the Services tab of Task Manager, which shows the services running inside the svchost.exe processes. Each group of services is a single svchost.exe process instance.

﻿

﻿

Figure 8.2-42

﻿

Since this process is commonly seen but simultaneously poorly understood by the average user, this process name is a frequent target of masquerade by threat actors to attempt to hide through obfuscation, which is described in MITRE technique ID T1036.005 Masquerading: Match Legitimate Name or Location. Additionally, due to its role as a host for services running with NT\System level privileges, which are the highest possible privileges in a Windows OS, this process is a frequent target for process injection as well, described in MITRE technique ID T1055 Process Injection, or spoofing svchost.exe as a parent PID for a malicious process, described in MITRE technique ID T1134.004 Access Token Manipulation: Parent PID Spoofing.

﻿

Additional Resources

MITRE ATT&CK Masquerading: Match Legitimate Name or Location: https://attack.mitre.org/techniques/T1036/005/
MITRE ATT&CK Masquerading: Masquerade Task or Service: https://attack.mitre.org/techniques/T1036/004/ 
MITRE ATT&CK Process Injection: https://attack.mitre.org/techniques/T1055/ 
MITRE ATT&CK Access Token Manipulation: Parent PID Spoofing: https://attack.mitre.org/techniques/T1134/004/ 
﻿

Desktop Windows Manager — dwm.exe
﻿

This process is a compositing window manager that renders a variety of graphical effects such as transparent windows, live taskbar thumbnails, and high-resolution monitor support. Windows uses this process to create one composite view of all the windows on the screen before sending it to your monitor. It uses the graphics buffers for each application and composites them together into one view. This prevents the uncertainty of effects that might be caused by applications writing their windows directly to the screen.

﻿

System Monitor — sysmon64.exe
﻿

While not standard to the Windows OS, this process is a standard endpoint logging application. It is a system service and device driver, and logs all activities dictated in its configuration directly to the Windows Event Log. It logs process creation, network connections, and modifications to file metadata such as creation time.

﻿

VMware Guest Authentication Service — VGAuthService.exe
﻿

This process is part of the Virtual Machine Software (VMware) tool suite that provides authentication for vSphere guest operations.

﻿

Microsoft Malware Protection Engine — MsMpEng.exe
﻿

This process is part of the Windows security architecture that checks the system for malware and manages security updates to the system. 

﻿

Microsoft Office Alternative User Input — ctfmon.exe
﻿

This is the Microsoft process that controls the Office language bar and alternative user inputs — such as through speech or a stylus — or using the onscreen keyboard inputs for foreign languages.

﻿

Console Windows Host — conhost.exe
﻿

This process is a host process for the Windows console, a category of applications that includes the Windows CMD.exe, Windows PowerShell, and other terminals hooking into the Windows console. This is a child process of csrss.exe, which was the host of the Windows console in earlier versions of the Windows OS. Each instance of CMD.exe spawns its own instance of conhost.exe.

﻿

DLL Launcher — rundll32.exe
﻿

This application is used to launch functionality stored in shared DLL files. The valid process is normally located at C:\Windows\System32\rundll32.exe, but sometimes malware uses the same filename and runs from a different directory in order to disguise itself, so determining the executable file path is important if this process is suspect. Additionally, threat actors may abuse the allowlists or false positives from normal operations associated with rundll32.exe to proxy execution of malicious code. By bootstrapping a shared module through rundll32.exe, instead of executing directly, they may avoid defensive mechanism on a system. This method is described further in MITRE technique ID T1218.011 Signed Binary Proxy Execution: Rundll32.

﻿

Additional Resources

MITRE ATT&CK Signed Binary Proxy Execution: Rundll32: https://attack.mitre.org/techniques/T1218/011/ 
MITRE ATT&CK Masquerading: Match Legitimate Name or Location: https://attack.mitre.org/techniques/T1036/005/
﻿

Windows Explorer — explorer.exe
﻿

This process manages the graphical shell component of the Windows OS, which includes the taskbar, Start menu, desktop, file manager, and other OS-wide UI features.

﻿

As both a highly visible and common process in the Windows OS, the Windows Explorer is a common target during privilege escalation, such as injecting shared library code into Explorer’s memory (MITRE ID T1055.001 Process Injection: Dynamic-link Library Injection) or spoofing explorer.exe as a parent process of a spawned PowerShell session rather than the malicious Office document that an unwitting user opened (MITRE ID T1134.004 Access Token Manipulation: Parent PID Spoofing). Searching for this process during the Discovery phase of post-exploitation allows a threat actor to determine if a user is logged on to the compromised system (MITRE ID T1057 Process Discovery).

﻿

Additional Resources

MITRE ATT&CK Process Discovery: https://attack.mitre.org/techniques/T1057/ 
MITRE ATT&CK Process Injection: DLL Injection: https://attack.mitre.org/techniques/T1055/001/ 
MITRE ATT&CK Access Token Manipulation: Parent PID Spoofing: https://attack.mitre.org/techniques/T1134/004/ 
﻿

Memory Compression
﻿

The task of compressing memory for efficient memory management has historically been a role of the System process, but in recent versions of Windows 10 has become the responsibility of the memory compression process. 

﻿

Sink to Receive Asynchronous Callbacks for WMI Client Application — unsecapp.exe
﻿

This process, as part of the WMI subsystem, is a channel for synchronizing information between the system and a remote computer. It is required for any program, service, or driver to interface with the Windows management framework and allows proper responses to requests and instructions from such software.

﻿

WMI Provider Service — WmiPrvSE.exe
﻿

This process performs essential error reporting and monitoring functions, and allows other applications on the computer to request information about the system. The management and monitoring services it provides are useful to some third-party applications. It allows those applications to run tasks and issue commands in a way that Windows understands.

﻿

DLL Host/Component Object Model (COM) Surrogate — dllhost.exe
﻿

This process is designed to launch one or more Windows OSs or applications. It runs a COM object outside the original process that requested it. If the COM object crashes, only the COM surrogate process crashes with it, rather than the requesting host process. If a developer is not fully confident in the code being loaded for an application, that developer likely employs the COM surrogate to host the code.

﻿

Additional Resources

MITRE ATT&CK Masquerading: Match Legitimate Name or Location: https://attack.mitre.org/techniques/T1036/005/
﻿

Microsoft Distributed Transaction Coordinator — msdtc.exe
﻿

This process is responsible for coordinating distributed transactions requested by client applications that span multiple resource managers across all servers, such as databases, message queues, and file systems.

﻿

Windows Search — SearchIndexer.exe
﻿

This process indexes the Windows file system in order to power the Windows search service and the functions that use it, such as the search boxes in the Start menu and Windows File Explorer.

﻿

Windows CLI — CMD.exe
﻿

This process is the CLI/terminal itself.

The Windows API
The Windows API is the intermediary interface that allows other programs to interact with the Windows OS. It can be used for many things such as manipulating or creating processes, modifying the registry, and enabling network connections. It can be thought of as a collection of predefined functions to do everything that needs to be done within the OS. Each function has specific input requirements and produces specific outputs, but how the function actually performs its task is not publicly documented by the Windows developers.

﻿

These functions are used for vastly more benign and normal behaviors in the broad suite of commercially- and privately-developed legitimate Windows applications than for anything malicious. The API calls referenced are specifically tailored to the need of that attack and used in anomalous fashion. Understanding how these functions are employed normally aids in identifying how they are employed abnormally. 

﻿

The functions that make up the Windows API — and are used to communicate with the Windows OS — are stored and accessed via Windows library files known as DLLs, which can be grouped into categories, some of which are explained below. Full documentation can be found in the Microsoft documentation. 

System Services: These libraries provide access to Windows file systems, devices, processes and threads, registry, and error handling.
Library DLLs:
kernel32.dll 
advapi32.dll 
ole32.dll
Graphics Device Interface: These libraries provide the functionality for outputting graphical content to monitors, printers, and other output devices.
Library DLLs:
gdi32.dll
User Interface (UI): These libraries include Common Dialog Box DLLs, which provide functions to create and interface with standard dialog boxes for opening and saving files, choosing color and font, etc.; Common Control Library DLLs, which provide access to status bars, progress bars, toolbars, tabs, and other advanced control features; and Windows Shell DLLs, which provide the functionality and modification of the OS shell.
Library DLLs:
comctl32.dll
comdlg32.dll
shell32.dll  
shlwapi.dll
user32.dll
Network Services: These libraries provide access to the various networking capabilities of the OS, including Network Basic Input/Output System (NetBIOS), Windows Sockets (Winsock), Network Dynamic Data Exchange (NetDDE), Remote Procedure Calls (RPC), and many others.
Library DLLs:
ws2_32.dll
wsock32.dll
wininet.dll
netapi32.dll
﻿

API Calls Common in Windows Malware
﻿

API calls with a high prevalence in Windows malware tend to come from one of the following standard DLLs. Understanding what the inclusion of those libraries indicates with regard to the malware’s functionality is a useful tool for the Cyber Defense Analyst (CDA) to determine the capabilities and extent of the malicious cyber activity.

﻿

Kernel32.dll: This is a very common DLL that contains core functionality, such as access and manipulation of memory, files, and hardware. Some of the common API calls in this DLL are:

ConnectNamedPipe: Creates a server pipe for interprocess communication that waits for a client pipe to connect. Some backdoors and reverse shells use ConnectNamedPipe to simplify or obfuscate connectivity to a Command and Control (C2) server.
CreateFile: Creates a new file or opens an existing file.
CreateFileMapping: Creates a handle to a file mapping that loads a file into memory and makes it accessible via memory addresses. Launchers, loaders, and injectors use this to read and modify PE files.
CreateProcess: Creates and launches a new process. If malware creates a new process, it needs to be analyzed as well.
CreateRemoteThread: Starts a thread in a remote process. Launchers and stealth malware use CreateRemoteThread to inject code into a different process.
EnumProcesses: Enumerates through running processes on the system. Malware enumerates through processes to find one into which to inject.
EnumProcessModules: Enumerates the loaded modules (executables and DLLs) for a given process. Malware enumerates through modules when performing an injection.
GetModuleFilename: Returns the filename of a module loaded in the current process. Malware uses this function to modify or copy files in the currently running process.
GetModuleHandle: Obtains a handle to an already loaded module. Processes use GetModuleHandle to locate and modify code in a loaded module or to search for a good location to inject code.
GetProcAddress: Retrieves the address of a function in a DLL loaded into memory. Imports functions from other DLLs and functions imported in the PE file header.
IsWoW64Process: Used by a 32-bit process to determine if it is running on a 64-bit OS.
LoadLibraryA/LoadLibraryEx: Function to load a DLL into a process.
OpenProcess: Opens a handle to another process running on the system. This handle reads and writes to the other process memory or injects code into the other process.
SetFileTime: Modifies the creation, access, or last modified time of a file. Malware often uses this function to conceal malicious activity.
VirtualAllocEx: A routine that allocates memory in a remote process. Malware uses VirtualAllocEx as part of a process injection.
WriteProcessMemory: Writes data to a remote process. Malware uses WriteProcessMemory as part of a process injection.
﻿

Advapi32.dll: This DLL provides access to advanced Windows core components, such as Service Manager and the registry. Some of the common API calls in this DLL are:

AdjustTokenPrivileges: Enables/disables specific access privileges. It allows malware to gain additional permissions in a process injection attack.
ControlService: Starts, stops, modifies, or sends a signal to a running service. Code needs to be analyzed that implements malicious services in order to determine the purpose of the call.
CreateService: Creates a service started at boot time. Malware uses CreateService for persistence, stealth, or to load kernel drivers.
RegCreateKeyEx: Creates a registry key.
RegDeleteKey: Deletes a registry subkey and its values.
﻿

WSock32.dll and Ws2_32.dll: These are networking DLLs. A program that accesses either of these most likely connects to a network or performs network-related tasks. Some of the common API calls in this DLL are:

Accept: Listens for incoming connections on a socket. Used by malware to communicate with the C2 server.
Bind: Associates a local address to a socket to listen for incoming connections.
Connect: Connects to a remote socket. Malware often uses low-level functionality to connect to a C2 server. Used by malware to communicate with the C2 server.
inet_addr: Converts an Internet Protocol (IP) address string  — like 127.0.0.1 — to the Windows structure used by other functions, such as Connect. The IP addresses found in these calls — and used in malware —  may be used in network-based signatures to identify potentially malicious activity. 
NOTE: Not all network activity by malware is useful for signatures as legitimate programs may communicate with the same IP addresses.
Recv: Receives data from a remote machine. Used by malware to receive data from a remote C2 server.
Send: Sends data to a remote machine. Used by malware to send data to a remote C2 server.
WSAStartup: Initializes low-level network functionality. Finding calls to WSAStartup is an easy way to locate the start of network-related functionality.
﻿

Wininet.dll: This DLL contains higher-level networking functions that implement protocols such as File Transfer Protocol (FTP), Hypertext Transfer Protocol (HTTP), and Network Time Protocol (NTP). Some of the common API calls in this DLL are:

FtpPutFile: Uploads a file to remote FTP server.
InternetOpen: Initializes the high-level internet access functions from Windows Internet (WinINet), such as InternetOpenUrl and InternetReadFile. Searching for InternetOpen is a good way to find the start of internet access functionality. One of the parameters to InternetOpen is the UserAgent, which may be a good network-based signature, if it is unique or not common.
InternetOpenUrl: Opens a specific Uniform Resource Locator (URL) for a connection using FTP, HTTP, or Hypertext Transfer Protocol Secure (HTTPS). URLs, if fixed, may be good network-based signatures.
InternetReadFile: Reads data from a previously opened URL.
InternetWriteFile: Writes data to a previously opened URL.
﻿

Ntdll.dll: The interface to the Windows kernel. Importing this DLL is one way that one can gain access to the undocumented Windows Native API.

﻿

NOTE: Executables generally do not import this DLL directly, although it is almost always imported indirectly through Kernel32.dll. If this DLL is imported directly, it is a significant red flag for a CDA. It implies that the author of the executable intended to use functionality not normally available to Windows programs. Some tasks, such as hiding functionality of malware or manipulating processes, use this interface. Additional information on many of these attacks is described in the MITRE Adversarial Tactics, Techniques, and Common Knowledge (ATT&CK) Technique ID T1106 Native API.
﻿

Figure 8.3-1 illustrates that while most other DLLs import the core Windows kernel functionality directly through kernel32.dll, a few import it through ntdll.dll as well, though few if any normal processes import from it.

Most DLLs require ntdll.dll because it contains the system service dispatch instructions for the Windows executive. Since user-mode processes have no other way of executing kernel-mode code and objects, ntdll.dll is the subsystem necessary to make allowed system calls to the kernel space. Most DLLs require ntdll.dll, the exceptions being GDI32.dll and User32.dll, which can make system calls directly to ntoskrnl.exe — the Windows kernel.

﻿

Additional Resources

MITRE ATT&CK Technique T1106 Native API: https://attack.mitre.org/techniques/T1106/ 
Windows API Index:  https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list ﻿
﻿

C:\Users\trainee>tasklist /s 172.16.3.2 /u Administrator /fi "imagename eq wmiprvse.exe" /m
C:\Users\trainee>tasklist /fi "imagename eq explorer.exe" /m



The /m switch displays all modules — meaning all loaded DLLs — associated with the selected processes. The /fi switch is a filter. It uses the quoted string immediately following the switch as a query on the list of all processes returned by tasklist.The imagename query selector indicates that results are filtered by the canonical name of the process.The eq query operator filters results in which the selector’s value is equivalent to the trailing expression.The [process] term is a regular expression, such as explorer or explore*.
Open a PowerShell terminal from the Start menu or the taskbar.


2. To view DLLs loaded by the explorer.exe process on the local machine, run the following command:


PS C:\Users\trainee> Get-Process “explorer” | Select-Object -ExpandProperty Modules -ErrorAction SilentlyContinue | Format-Table -Autosize

DLL Injection
Classic DLL injection is an attack performed by writing the path of a malicious DLL into the virtual address space of a target process, resulting in malicious code execution under the guise of a remote thread created by the target process. Due to the types of functions executed (memory manipulation, acquiring process handles, etc.), this type of attack can only be performed in the context of administrator-level permissions.

﻿

This is performed in three steps: 

﻿

Target Selection
﻿

After identifying a process for injection, such as explorer.exe, the malware searches through the existing processes by using the following API calls:

CreateToolhelp32Snapshot
Process32First
Process32Next
OpenProcess
CreateToolhelp32Snapshot is first called to enumerate heap or module states of a specified process or all processes. Process32First and Process32Next are used to iterate through the snapshot structure returned from the first function, each returning information about the enumerated processes. Once the malware has received the information for the target process from one of these API calls, it calls OpenProcess to obtain a handle to the target process.

﻿

Memory Allocation
﻿

Once the handle to a target process is obtained, the malware injects the path to its malicious DLL with the following API calls:

VirtualAllocEx
WriteProcessMemory
VirtualAllocEx creates a virtual memory block large enough to hold a file path in order to have a writeable space inside the target process. The malware then writes the path to the malicious DLL in the allocated memory using WriteProcessMemory.

﻿

VirtualAllocEx is necessary for this step because prior to writing to a block of memory in a computer, the block must be allocated for use. Allocating memory is a system internal to the OS that reserves portions of memory for a specific process’s use in order to avoid memory in use being overwritten and lost.

﻿

When a process is allocating additional memory for its own use, it uses the function VirtualAlloc, but when it is allocating space in a different process, VirtualAllocEx is used.

﻿

It is important to note that VirtualAlloc and VirtualAllocEx are used to allocate larger scale blocks of memory, not small byte-sized chunks for variables. For example, if a developer used the line

﻿

void* pAddress = VirtualAlloc(NULL, 8, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
﻿

to allocate memory for an 8-byte value, the developer actually allocated an entire page of memory, the size of which varies from system to system, but is often four kilobytes (kb) rather than eight bytes.

Remote Thread Creation

Finally, to execute code in the target process, the malware calls one of the following APIs:

CreateRemoteThread
NtCreateThreadEx (undocumented)
RtlCreateUserThread (undocumented)
Effectively, executing any one of these functions — by passing the address of the API call LoadLibrary and the address returned from VirtualAllocEx that points to the memory storing the malicious DLL path — successfully results in a remote process that executes the DLL on behalf of the malware.

NOTE: As remarked above, there are a number of undocumented API calls. These occur when developers internal to Microsoft add functionality to the common libraries but do not intend for their code to be widely accessed. They are undocumented for a number of reasons such as testing, not intended for long term use, or other reasons. These functions are subject to change at any time, and their inputs/outputs are not guaranteed to always be the same. Microsoft provides other functions that are documented as a go-between for the undocumented functions, which are intended for programmers to use. These undocumented functions can still be discovered by dumping the export table of a shared library — usually ntdll.dll — and tracing the functions back to their entry points and conducting a reverse engineering of the assembly code there. Since these functions do not provide an intuitive insight into their function until documentation is developed, they are valued tools of malware developers seeking to obfuscate their tools. That is often an indication of possible maliciousness. 

Windows API in Both Malicious and Non-Malicious Contexts
Each of these API calls exists because they can be and are used for many valid purposes and are commonly employed as such. 

For example:

GetUserName and GetComputerName are frequently and benignly used to obtain the current context in which a program is running. A piece of malware could use it for information gathering on a newly exploited system. 
FindExecutable is used to obtain the path to a Windows binary that a process relies on as a dependency.
GetTempPath is used to enable one-off filesystem operations performed by processes, and is also a way for malware to create and hide its on-disk activity.
The function CheckKeyboardBuffer could be used by normal software to determine whether an expected key was pressed, or it could be used by a piece of malware to peek at what is being typed. 
﻿

The Windows API exists because developers needed a reliable and well-defined method of accessing kernel-level information and objects while writing user-land code, so it is widely used for very good reasons. This lesson illustrates that the types of calls that a process makes give some insight into its behavior or potential functionality. 

And in some cases, the particular sequence or composition of API calls is highly characteristic of malicious behavior. This kind of sequencing is illustrated by an examination of the types of calls made in a classic DLL injection.

Some of the specific API calls used by the Cerber malware were used to selectively determine if the malware infected a particular machine. The relevant API calls are described below (and are available in the Help Viewer on cda-flare).


GetKBCodePage returns the Original Equipment Manufacturer (OEM) code-page identifier that specifies the manufacturing origin and likely keyboard layout.


GetLocaleInfoW returns identifiers that indicate the region and language options specified in the control panel.


NOTE: The previous question included GetSystemTime, which is incorrect. The reason this API call does not indicate geography is because it returns the time in Coordinated Universal Time (UTC). If the API call had been GetLocalTime, that function returns the local time as an offset of UTC and may indicate the time zone the system is operating in, if properly configured. Threat actors often include these types of checks to target specific industries or networks, and to also prevent infection of other types of networks or industries they want to protect. CDAs should be aware of this type of behavior in their analysis of potentially malicious binaries.

process(.exe)=import
dll=export
Dynamic Analysis
Use what you have learned so far about observing the real-time logs of operations/Windows API calls performed by processes to determine what sort of behavior they are exhibiting. In this exercise, three PowerShell scripts left behind by a threat actor on the mission partner’s network are collected. Run them on the cda-flare VM — which is a sandboxed reverse engineering platform — to discover what each one does. 

﻿

1. Log in to the cda-flare VM using the following credentials:

﻿

Username: trainee
Password: Th1s is 0perational Cyber Training!
﻿

2. Use the following filters in Process Monitor:

Operation is WriteFile
Operation is Process Create
Operation is RegSetValue
Operation is SetDispositionInformationFile
Operation is SetDispositionInformationEx
Process Name is powershell.exe
:\WINDOWS\system32>listdlls createremotethread
C:\WINDOWS\system32>listdlls putty
Observe that the putty.exe process has a DLL loaded from a directory outside the c:\Windows\* structure. The c:\dllinject\dllinject.dll DLL looks suspicious and warrants further investigation and isolation if something similar is found in a mission partner’s systems.


Here are some great options:

Olympus XA2 – A compact 35mm camera with a sharp lens and natural grain retention.

Canon AE-1 Program – A classic SLR that lets you control exposure for that dreamy, cinematic effect.

Minolta Hi-Matic AF2 – A point-and-shoot with a built-in flash that enhances moody lighting.

Pentax K1000 – Fully manual, perfect for experimenting with grain-heavy film stocks.

For film, consider Kodak Tri-X 400 or Ilford HP5 Plus for rich grain and deep contrast. If you want color, Kodak Portra 800 or Cinestill 800T will give you that nostalgic, cinematic glow.
Leica M6 – A legendary rangefinder with a sharp lens that retains natural grain and depth.

Pentax 67 – A medium-format camera that delivers cinematic, painterly images with rich tonal range.

Kiev 60 – A Soviet-era medium-format camera that produces hauntingly textured images, perfect for that melancholic Tarkovsky feel.

Zenit E – A classic Russian 35mm camera with a Helios 44-2 lens, known for its dreamy, swirling bokeh and deep contrast.
Kodak Tri-X 400 – High grain, deep shadows, and a timeless cinematic look.

Ilford HP5 Plus – A moody black-and-white film with rich contrast and texture.

Cinestill 800T – If you want color with a nostalgic glow, this tungsten-balanced film gives a cinematic, ethereal quality.















